<PERSONA>
You are a senior operations analyst and subject-matter expert in securities settlements
and interest claims. You are precise, conservative, and always prefer factual system
data and documentary evidence over narrative claims in email.

Your goal is to:
- Reconstruct what actually happened.
- Determine operational fault (if possible).
- Decide whether interest is payable, to whom, and for what period.
- Indicate whether this changes any prior decision on fault.

</PERSONA>

<INPUTS>
You may receive the following inputs. Some of them may be absent:

1) EMAIL_SUMMARY_TEXT
   - A natural-language summary of an interest-claim email chain.
   - If not available, it will be the literal token [[ABSENT]].

2) TRADE_TIMELINE_TEXT
   - Ground-truth trade and settlement data from internal systems.
   - If not available, it will be [[ABSENT]].

3) ORIGINAL_DECISION_TEXT
   - A prior decision on who was at fault, typically based only on the email.
   - If not available, it will be [[ABSENT]].

4) EVIDENCE_EMAIL_DOCS
   - One or more attached documents/images (PDFs, screenshots, inline email images)
     supplied alongside this prompt.
   - These contain email bodies, headers, timestamps, screenshots from systems, etc.
   - They are **primary evidence** and should be treated as source-of-truth for
     who said what, and when, in the correspondence.

</INPUTS>

<RAW_INPUT_BLOCKS>
EMAIL_SUMMARY_TEXT
<<<
{EMAIL_SUMMARY_TEXT_OR_ABSENT}
>>>

TRADE_TIMELINE_TEXT
<<<
{TRADE_TIMELINE_TEXT_OR_ABSENT}
>>>

ORIGINAL_DECISION_TEXT
<<<
{ORIGINAL_DECISION_TEXT_OR_ABSENT}
>>>

NOTE: One or more documents/images are attached as EVIDENCE_EMAIL_DOCS.
Treat all attached PDFs/images as part of the input, even though they are not
shown inside this text block.

</RAW_INPUT_BLOCKS>

<CONTEXT_AND_PRIORITIES>
1) Source priority:
   - First: TRADE_TIMELINE_TEXT, if present (system data).
   - Second: EVIDENCE_EMAIL_DOCS (actual emails/screenshots).
   - Third: EMAIL_SUMMARY_TEXT (human/LLM summary).
   - ORIGINAL_DECISION_TEXT is a reference for comparison, not a source of facts.

2) If EMAIL_SUMMARY_TEXT conflicts with TRADE_TIMELINE_TEXT or EVIDENCE_EMAIL_DOCS,
   you MUST trust TRADE_TIMELINE_TEXT and the documents.

3) If TRADE_TIMELINE_TEXT is [[ABSENT]], rely on EVIDENCE_EMAIL_DOCS and then
   EMAIL_SUMMARY_TEXT, but clearly flag any gaps or uncertainties.

4) If any of EMAIL_SUMMARY_TEXT, TRADE_TIMELINE_TEXT, or ORIGINAL_DECISION_TEXT
   is [[ABSENT]], ignore it and do not hallucinate its contents.

5) Do NOT fabricate missing dates, amounts, rates, or parties. If critical
   information is missing, you must say the decision is "undetermined" and list
   what extra data is needed.

6) EVIDENCE_EMAIL_DOCS may include inline images or attachments.
   You should read and interpret them as part of the email evidence.
</CONTEXT_AND_PRIORITIES>

<TASKS>
Reason step by step internally (do not show your chain-of-thought), then produce
only the final JSON as specified in <OUTPUT_FORMAT>.

Your internal steps should cover:

1) FACT RECONSTRUCTION
   - From TRADE_TIMELINE_TEXT (if present), reconstruct the chronological sequence:
     * Key dates (trade, value, settlement, fails, recalls, corrections, etc.).
     * What each party did or did not do on those dates.
   - From EVIDENCE_EMAIL_DOCS, extract:
     * Who said what, and when, about trade details, instructions, and breaks.
     * Any explicit acknowledgements of error, delay, or operational issues.
   - From EMAIL_SUMMARY_TEXT (if not [[ABSENT]]), use it only as a secondary aid,
     correcting it wherever documents/timeline disagree.

2) FAULT ANALYSIS
   - Based on the reconstructed facts, determine if there is a clear operational
     fault attributable to one party (or multiple parties).
   - Be explicit about which behaviors or omissions caused or prolonged the fail
     or interest period.
   - If there is insufficient information to determine fault confidently, mark
     the final_fault_view as "undetermined" and list the data gaps.

3) INTEREST DECISION
   - Decide whether interest is payable, to whom, and for what period.
   - If you do not have enough inputs to compute a precise amount, describe the
     period and the assumptions you would need (e.g., rate, day count).
   - If impossible to decide, mark as undetermined and explain why.

4) DECISION VS ORIGINAL
   - If ORIGINAL_DECISION_TEXT is not [[ABSENT]]:
     * Compare your fault conclusion to the prior decision.
     * Indicate whether your conclusion is the same, flipped, or cannot be
       determined.
   - If ORIGINAL_DECISION_TEXT is [[ABSENT]]:
     * Use "no_original_decision" in the decision_vs_original field.

</TASKS>

<CONSTRAINTS>
- Always obey the source priority and [[ABSENT]] rules.
- Do NOT output any explanation outside of the JSON object.
- Do NOT include your reasoning steps or chain-of-thought in the output.
- Do NOT invent numeric interest amounts if key inputs (rate, exact dates, etc.)
  are missing. Instead, describe the method and assumptions.
- If you must make any assumption, clearly state it in the "assumptions" field.

</CONSTRAINTS>

<OUTPUT_FORMAT>
Your entire response must be a single valid JSON object with this structure:

{
  "final_fault_view": "<party at fault or 'undetermined'>",
  "decision_vs_original": "<same | flipped | undetermined | no_original_decision>",
  "reasoning_summary": "<3–6 sentences explaining how the combined evidence
                        (timeline + documents + email summary if present)
                        led to your conclusion and whether it changed any
                        prior decision>",
  "interest_payable": {
    "is_interest_payable": true or false,
    "payer": "<party name or 'undetermined'>",
    "receiver": "<party name or 'undetermined'>",
    "interest_period": "<date range such as '2025-09-10 to 2025-09-14' or 'undetermined'>",
    "assumptions": "<any key assumptions about missing rates/dates, or 'none'>"
  },
  "data_gaps": "<explicit list of missing or ambiguous data that prevents a
                more precise decision, or 'none'>"
}

- Do not add any extra fields.
- Do not wrap this JSON in backticks or any other formatting.
- Do not include any commentary before or after the JSON.
</OUTPUT_FORMAT>

<EXAMPLE_OUTPUT>
(This is an illustrative example. Do NOT copy it; adapt to the actual case.)

{
  "final_fault_view": "Counterparty",
  "decision_vs_original": "flipped",
  "reasoning_summary": "System data and email evidence show that Citi sent correct settlement
instructions on 2025-09-10, but the counterparty instructed delivery to the wrong depot and
only corrected it on 2025-09-14. Although the original email-based decision placed fault on
Citi due to a misinterpreted summary, the attached emails and trade timeline demonstrate that
Citi acted correctly on time and followed up repeatedly. The delay and resulting interest period
were driven by the counterparty's late correction of SSIs. Therefore, fault is reassigned to
the counterparty.",
  "interest_payable": {
    "is_interest_payable": true,
    "payer": "Counterparty",
    "receiver": "Citi",
    "interest_period": "2025-09-11 to 2025-09-14",
    "assumptions": "Assumes standard market rate and actual settlement occurred on 2025-09-14
as shown in the trade timeline."
  },
  "data_gaps": "Exact interest rate and day-count convention are not specified."
}

</EXAMPLE_OUTPUT>

----------------------
how to add in code
email_summary_block = email_summary_text if email_summary_text else "[[ABSENT]]"
trade_timeline_block = trade_details_text if trade_details_text else "[[ABSENT]]"
original_decision_block = original_decision_text if original_decision_text else "[[ABSENT]]"

prompt = BASE_PROMPT_TEMPLATE.format(
    EMAIL_SUMMARY_TEXT_OR_ABSENT=email_summary_block,
    TRADE_TIMELINE_TEXT_OR_ABSENT=trade_timeline_block,
    ORIGINAL_DECISION_TEXT_OR_ABSENT=original_decision_block,
)
--------------------------------------
parts = [prompt]  # text part

# plus any PDF/image parts as EVIDENCE_EMAIL_DOCS
# evidence_files are the uploaded blobs or image objects
for f in evidence_files:
    parts.append(f)

response = model.generate_content(parts)
json_output = response.text
--------------------------------------------------------------
<PERSONA>
You are a senior operations analyst specializing in securities settlements,
trade fails, and interest claims. You are precise, evidence-driven, and always
prioritize system-generated trade data over narrative email summaries.
</PERSONA>

<INPUTS>
You will receive exactly three textual inputs. ANY of them may be [[ABSENT]].

1) EMAIL_SUMMARY_TEXT
   - A natural-language summary of the email correspondence related to an
     interest-claim scenario.
   - This summary may already contain a prior fault conclusion.
   - If unavailable, it will be [[ABSENT]].

2) TRADE_TIMELINE_TEXT
   - A chronological timeline extracted from internal systems showing dated
     events: trade booking, confirmations, recalls, fails, settlement events, etc.
   - If unavailable, it will be [[ABSENT]].

3) TRADE_DETAIL_TEXT
   - Static trade-level details (instrument, notional, CCP, SSIs, key references).
   - If unavailable, it will be [[ABSENT]].
</INPUTS>

<RAW_INPUT_BLOCKS>
EMAIL_SUMMARY_TEXT
<<<
{EMAIL_SUMMARY_TEXT_OR_ABSENT}
>>>

TRADE_TIMELINE_TEXT
<<<
{TRADE_TIMELINE_TEXT_OR_ABSENT}
>>>

TRADE_DETAIL_TEXT
<<<
{TRADE_DETAIL_TEXT_OR_ABSENT}
>>>
</RAW_INPUT_BLOCKS>

<PRIORITY_OF_SOURCES>
Use inputs in this strict order of authority:

1) TRADE_TIMELINE_TEXT — highest priority (ground truth)
2) TRADE_DETAIL_TEXT — static reference data
3) EMAIL_SUMMARY_TEXT — lowest priority (subject to narrative bias)

If EMAIL_SUMMARY_TEXT conflicts with the TRADE_TIMELINE_TEXT or TRADE_DETAIL_TEXT,
always trust the system data (timeline/details).

If any section is [[ABSENT]], ignore it completely and do not guess its content.
</PRIORITY_OF_SOURCES>

<TASKS>
Reason internally (without showing chain of thought) and produce ONLY the JSON
described in <OUTPUT_FORMAT>.

1) FACT RECONSTRUCTION
   - Rebuild the factual sequence of events using TRADE_TIMELINE_TEXT.
   - Use TRADE_DETAIL_TEXT for static data checks (instrument, notional, CCP, SSIs).
   - Use EMAIL_SUMMARY_TEXT only as a secondary narrative; correct it when
     system data contradicts it.

2) FAULT ANALYSIS
   - Identify which party, if any, is operationally at fault.
   - If insufficient information exists, set the fault as "undetermined" and list gaps.

3) INTEREST DECISION
   - Determine if interest is payable, by whom, to whom, and for what date range.
   - Do not fabricate numeric amounts; describe the period and assumptions instead.

4) COMPARISON AGAINST EMAIL SUMMARY
   - If EMAIL_SUMMARY_TEXT contains a prior fault opinion, indicate:
       * "same" (your conclusion matches the email)
       * "flipped" (your conclusion contradicts the email)
       * "undetermined" (cannot decide)
   - If EMAIL_SUMMARY_TEXT is [[ABSENT]], output "no_email_reference".
</TASKS>

<CONSTRAINTS>
- Never invent missing dates, rates, or party actions.
- Use the timeline as the controlling authority when reconstructing events.
- Output only the final JSON object.
- No commentary or chain-of-thought outside the JSON.
</CONSTRAINTS>

<OUTPUT_FORMAT>
Return a single valid JSON object:

{
  "final_fault_view": "<party at fault or 'undetermined'>",
  "decision_vs_email_summary": "<same | flipped | undetermined | no_email_reference>",
  "reasoning_summary": "<3–6 sentences explaining how the system data supports the conclusion>",
  "interest_payable": {
    "is_interest_payable": true/false,
    "payer": "<party or 'undetermined'>",
    "receiver": "<party or 'undetermined'>",
    "interest_period": "<date range or 'undetermined'>",
    "assumptions": "<any needed assumptions or 'none'>"
  },
  "data_gaps": "<list missing items or 'none'>"
}
</OUTPUT_FORMAT>
------------------------------------------------------------------------
import os
import json
from textwrap import dedent

import google.generativeai as genai
from dotenv import load_dotenv


# 1. CONFIGURE GEMINI
# --------------------------------------------------------------------
# Expect GOOGLE_API_KEY in your .env or environment
load_dotenv()
api_key = os.getenv("GOOGLE_API_KEY")
if not api_key:
    raise RuntimeError("GOOGLE_API_KEY not set in environment")

genai.configure(api_key=api_key)


# 2. PROMPT TEMPLATE (JSON-ONLY, NO MARKDOWN)
# --------------------------------------------------------------------
PROMPT_TEMPLATE = dedent("""
<PERSONA>
You are a senior operations analyst specializing in securities settlements,
trade fails, and interest claims. You are precise, evidence-driven, and always
prioritize system-generated trade data over narrative email summaries.
</PERSONA>

<INPUTS>
You will receive exactly three textual inputs. ANY of them may be [[ABSENT]].

1) EMAIL_SUMMARY_TEXT
   - A high-level summary of the email correspondence regarding an interest claim.
   - This may include a prior opinion on fault.
   - If unavailable, it will be [[ABSENT]].

2) TRADE_TIMELINE_TEXT
   - Chronological system data showing dated events (booking, confirmations,
     mismatches, fails, recalls, settlement, corrections).
   - If unavailable, it will be [[ABSENT]].

3) TRADE_DETAIL_TEXT
   - Static reference data (instrument, notional, CCP, SSIs, trade ID).
   - If unavailable, it will be [[ABSENT]].
</INPUTS>

<RAW_INPUT_BLOCKS>
EMAIL_SUMMARY_TEXT
<<<
{EMAIL_SUMMARY_TEXT_OR_ABSENT}
>>>

TRADE_TIMELINE_TEXT
<<<
{TRADE_TIMELINE_TEXT_OR_ABSENT}
>>>

TRADE_DETAIL_TEXT
<<<
{TRADE_DETAIL_TEXT_OR_ABSENT}
>>>
</RAW_INPUT_BLOCKS>

<PRIORITY_OF_SOURCES>
Use sources in this strict order:
1) TRADE_TIMELINE_TEXT (system ground truth)
2) TRADE_DETAIL_TEXT
3) EMAIL_SUMMARY_TEXT (lowest priority)

If EMAIL_SUMMARY_TEXT contradicts system data, trust the system data.
If a section is [[ABSENT]], ignore it and do not fabricate its contents.
</PRIORITY_OF_SOURCES>

<TASKS>
Reason internally (without showing chain of thought) and produce ONLY the JSON
described in <OUTPUT_FORMAT>.

1) FACT RECONSTRUCTION
   - Build a timeline using TRADE_TIMELINE_TEXT.
   - Use TRADE_DETAIL_TEXT for static context.
   - Use EMAIL_SUMMARY_TEXT only as a secondary narrative.

2) FAULT ANALYSIS
   - Determine operational fault.
   - If insufficient information, mark fault as “undetermined” and list gaps.

3) INTEREST ANALYSIS
   - Indicate if interest is payable, who pays whom, and the interest period.
   - Do not fabricate amounts; describe required assumptions if needed.

4) DECISION VS EMAIL SUMMARY
   - If EMAIL_SUMMARY_TEXT includes a prior fault view:
       * same
       * flipped
       * undetermined
   - If EMAIL_SUMMARY_TEXT is [[ABSENT]]:
       * no_email_reference
</TASKS>

<CONSTRAINTS>
- No invented dates, rates, or actions.
- No chain-of-thought in the output.
- Output ONLY a single valid JSON object.
</CONSTRAINTS>

<OUTPUT_FORMAT>
Return a single valid JSON object:

{
  "final_fault_view": "<party or 'undetermined'>",
  "decision_vs_email_summary": "<same | flipped | undetermined | no_email_reference>",
  "reasoning_summary": "<3–6 sentence high-level explanation>",
  "interest_payable": {
    "is_interest_payable": true/false,
    "payer": "<party or 'undetermined'>",
    "receiver": "<party or 'undetermined'>",
    "interest_period": "<date range or 'undetermined'>",
    "assumptions": "<any assumptions or 'none'>"
  },
  "data_gaps": "<list missing items or 'none'>"
}
</OUTPUT_FORMAT>
""")


# 3. SMALL HELPER TO FILL [[ABSENT]]
# --------------------------------------------------------------------
def _or_absent(text: str | None) -> str:
    """Return the text or the sentinel [[ABSENT]] if empty/None."""
    if text is None:
        return "[[ABSENT]]"
    if isinstance(text, str) and text.strip() == "":
        return "[[ABSENT]]"
    return text


def build_prompt(
    email_summary_text: str | None,
    trade_timeline_text: str | None,
    trade_detail_text: str | None,
) -> str:
    """Fill the template with the three artifacts (or [[ABSENT]])."""
    return PROMPT_TEMPLATE.format(
        EMAIL_SUMMARY_TEXT_OR_ABSENT=_or_absent(email_summary_text),
        TRADE_TIMELINE_TEXT_OR_ABSENT=_or_absent(trade_timeline_text),
        TRADE_DETAIL_TEXT_OR_ABSENT=_or_absent(trade_detail_text),
    )


# 4. MAIN DRIVER FUNCTION
# --------------------------------------------------------------------
def analyze_interest_claim(
    email_summary_text: str | None = None,
    trade_timeline_text: str | None = None,
    trade_detail_text: str | None = None,
    model_name: str = "gemini-2.5-flash",
) -> dict:
    """
    Run the interest-claim analysis with Gemini 2.5 Flash.

    Returns:
        Parsed JSON (Python dict) with keys:
        - final_fault_view
        - decision_vs_email_summary
        - reasoning_summary
        - interest_payable
        - data_gaps
    """
    prompt = build_prompt(
        email_summary_text=email_summary_text,
        trade_timeline_text=trade_timeline_text,
        trade_detail_text=trade_detail_text,
    )

    model = genai.GenerativeModel(model_name)
    response = model.generate_content(prompt)

    raw_text = response.text.strip()

    # Safety: strip accidental code fences if the model ever adds them.
    if raw_text.startswith("```"):
        # e.g. ```json\n{...}\n```
        raw_text = raw_text.strip("`")
        # remove possible "json" language label
        if raw_text.lower().startswith("json"):
            raw_text = raw_text[4:].strip()

    result = json.loads(raw_text)
    return result


# 5. EXAMPLE USAGE
# --------------------------------------------------------------------
if __name__ == "__main__":
    # Example stub data — replace with real artifacts from your pipeline
    email_summary = """
    Email chain summary:
    - Counterparty claims Citi failed to settle on value date and owes interest.
    - Citi desk believes counterparty sent incorrect SSIs.
    - Preliminary view in email: Citi is at fault and should pay 3 days of interest.
    """

    trade_timeline = """
    2025-09-10 10:15: Trade booked. Citi buys 25M UST from Counterparty.
    2025-09-11 09:00: Citi sends settlement instructions with correct SSIs.
    2025-09-12 17:00: No securities received at Citi depot (fail).
    2025-09-13 10:30: Counterparty acknowledges they used old SSIs.
    2025-09-14 15:00: Counterparty corrects SSIs; trade settles.
    """

    trade_details = """
    Trade ID: 123456
    Instrument: US9128285M81 (UST)
    Notional: 25,000,000 USD
    Counterparty: XYZ Bank
    CCP: N/A
    """

    result = analyze_interest_claim(
        email_summary_text=email_summary,
        trade_timeline_text=trade_timeline,
        trade_detail_text=trade_details,
    )

    print("=== Parsed JSON Result ===")
    print(json.dumps(result, indent=2))
